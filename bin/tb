#!/usr/bin/python3
from pathlib import Path
from datetime import datetime, timezone
import enum
import fcntl
import functools
import itertools
import json
import os
import re
import tempfile
import shutil
import sys


eprint = functools.partial(print, file=sys.stderr)



class SandboxError(Exception):
    pass


class SandboxUnavailableError(SandboxError):
    pass


class Type(enum.Enum):
    create = 0
    start = 1
    list = 2
    list_advanced = 3
    remove = 4
    help = 5


class Sandbox:
    base_dir = Path('~/.local/share/tor-browser-sandboxes').expanduser()
    link_dir = Path('~/td').expanduser()
    exec = 'sandboxed-tor-browser'
    pulse_cookie = Path('~/.config/pulse/cookie').expanduser()
    pulse_server = 'unix:/var/run/user/{}/pulse/native'.format(os.getuid())
    is_valid_name = re.compile('^[A-Za-z0-9_][A-Za-z0-9_-]*$')

    def __init__(self, args):
        self.name = None
        self.create_base_dir()

        arg = args[1] if len(args) > 1 else ''
        if arg == '++':  # list sandboxes
            self.type = Type.list
        elif arg.startswith('++add+'):  # create sandbox
            self.type = Type.create
            self.name = arg[6:]
            self.args = args[2:]
        elif arg.startswith('++del+'):  # remove sandbox
            self.type = Type.remove
            self.name = arg[6:]
        elif arg == '++help':
            self.type = Type.help
        elif arg == '++list':
            self.type = Type.list_advanced
        elif arg.startswith('++'):
            raise SandboxError('Unknown command {!r}.'.format(arg))
        elif arg == '+':
            raise SandboxError('Expected name after \'+\'')
        elif arg.startswith('+'): # start given sandbox
            self.type = Type.start
            self.name = arg[1:]
            self.args = args[2:]
        else:  # start and/or create an auto* sandbox
            self.type = Type.create
            self.name = self.find_free_auto()
            self.args = args[1:]

        if self.name is not None:
            self.path = self.base_dir / self.name

    def find_free_auto(self):
        prefix = 'auto'
        for i in itertools.count():
            name = prefix + str(i)
            if not self.is_locked(name):
                return name

    def is_locked(self, name):
        lockfile = self.base_dir / name / 'runtime' / 'sandboxed-tor-browser' / 'lock'
        if not lockfile.exists():
            return False

        with lockfile.open() as f:
            try:
                fcntl.flock(f.fileno(), fcntl.LOCK_SH|fcntl.LOCK_NB)
                return False
            except BlockingIOError:
                return True

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, name):
        if name is not None and not self.is_valid_name.search(name):
            raise SandboxError('Sandbox name {!r} must match pattern {!r}.'.format(name, self.is_valid_name.pattern))
        self._name = name

    def pid_file(self, name):
        return self.base_dir / (name + '.pid')

    def create_sandbox(self):
        self.create_base_dir()
        self.create_download_link()

    def create_base_dir(self):
        self.base_dir.mkdir(mode=0o700, exist_ok=True)

    def create_download_link(self):
        self.link_dir.mkdir(mode=0o700, exist_ok=True)
        src = self.path / 'data' / 'sandboxed-tor-browser' / 'tor-browser' / 'Browser' / 'Downloads'
        dest = self.link_path()
        if not dest.is_symlink():
            dest.symlink_to(src, target_is_directory=True)

    def link_path(self):
        return self.link_dir / self.name

    def create_logfile(self):
        dir = '/dev/shm'
        if os.access(dir, os.W_OK) and os.path.ismount(dir):
            with tempfile.NamedTemporaryFile(
                    mode='w',
                    prefix='tb-{}-'.format(self.name),
                    suffix='.log',
                    dir=dir,
                    delete=False) as f:
                json.dump({
                    'name': self.name,
                    'start': datetime.now(timezone.utc).astimezone().strftime('%Y-%m-%dT%H:%M:%S.%f%z'),
                    'pid': os.getpid(),
                    'args': self.args
                }, f)
                f.write('\n')
                f.flush()
            return f.name

    def execute(self):
        if self.type == Type.create:
            self.create_sandbox()
            self.args = [ '-advanced' ] + self.args
            self.start_sandbox()
        elif self.type == Type.start:
            self.check_sandbox_exists()
            self.start_sandbox()
        elif self.type == Type.list:
            self.print_sandboxes()
        elif self.type == Type.list_advanced:
            self.print_sandboxes_advanced()
        elif self.type == Type.remove:
            self.check_sandbox_exists()
            self.remove_sandbox()
        elif self.type == Type.help:
            self.usage()
        else:
            raise AssertionError()

    def start_sandbox(self):
        args = ['-debug']
        env = os.environ.copy()
        env.update(
            XDG_RUNTIME_DIR = (self.path / 'runtime').as_posix(),
            XDG_CONFIG_HOME = (self.path / 'config').as_posix(),
            XDG_DATA_HOME   = (self.path / 'data').as_posix(),
            PULSE_COOKIE    = self.pulse_cookie.as_posix(),
            PULSE_SERVER    = self.pulse_server
        )

        if self.is_locked(self.name):
            raise SandboxUnavailableError('Sandbox {!r} already running'.format(self.name))

        with self.pid_file(self.name).open('w') as f:
            print(os.getpid(), file=f)

        logfile = self.create_logfile()
        if logfile is not None:
            args.extend(['-l', logfile])

        os.execvpe(self.exec, [self.exec] + args + self.args, env)

    def check_sandbox_exists(self):
        if not self.path.exists():
            raise SandboxUnavailableError('No sandbox named {!r}.'.format(self.name))

    def list_sandboxes(self):
        if self.base_dir.exists():
            return sorted(filter(lambda i: i.is_dir(), self.base_dir.iterdir()))
        else:
            return []

    def print_sandboxes(self):
        for sandbox in self.list_sandboxes():
            print(sandbox.stem)

    def print_sandboxes_advanced(self):
        print('NAME       PID      VERSION  CHANNEL  VOLATILE  AUDIO')
        for sandbox in self.list_sandboxes():
            pid_file = self.pid_file(sandbox.stem)
            if self.is_locked(sandbox.stem) and pid_file.exists():
                with pid_file.open() as f:
                    running = f.read().strip()
            else:
                running = '-'
            config = self.parse_config(sandbox)
            print('{:10} {:8} {version:8} {channel:8} {volatile:9} {audio:5}'.format(sandbox.stem, running, **config))

    def parse_config(self, base_dir):
        sb_config = base_dir / 'config' / 'sandboxed-tor-browser' / 'sandboxed-tor-browser.json'
        manifest = base_dir / 'data' / 'sandboxed-tor-browser' / 'manifest.json'
        audio = '?'
        channel = '?'
        version = '?'
        volatile = '?'

        if sb_config.exists():
            with sb_config.open() as f:
                content = json.load(f)

            if not content.get('firstLaunch', True):
                channel = content.get('channel', '?')
                sandbox = content.get('sandbox')
                if sandbox is not None:
                    volatile = str(sandbox.get('enableAmnesiacProfileDirectory', '?'))
                    audio = str(sandbox.get('enablePulseAudio', '?'))

        if manifest.exists():
            with manifest.open() as f:
                content = json.load(f)
            version = content.get('version', '?')

        return { 'channel': channel, 'volatile': volatile, 'audio': audio, 'version': version }

    def remove_sandbox(self):
        def handler(func, path, exc):
            eprint('failed to remove {!r}: {}'.format(path, exc[1]))

        if self.path.exists():
            shutil.rmtree(self.path.as_posix(), onerror=handler)
        link = self.link_path()
        if link.is_symlink():
            link.unlink()

    @staticmethod
    def usage():
        eprint("Usage: {} [+NAME|++|++add+NAME|++del+NAME|++list] [ARG_FOR_SANDBOX]...".format(sys.argv[0]),
               "",
               "  ++help       show this text",
               "  +NAME        start sandbox with name NAME",
               "  ++           list available sandboxes (names only)",
               "  ++list       list available sandboxes with details",
               "  ++add+NAME   create and start sandbox with name NAME (starts sandbox",
               "               if it already exists)",
               "  ++del+NAME   irrecoverably remove sandbox with name",
               "",
               "  Only one argument starting with + is allowed and it must be",
               "  the first argument. The ARG_FOR_SANDBOX arguments are passed on",
               "  to the sandbox sandbox process. Obmitting the argument behaves",
               "  as if called with ++add+default.",
               sep='\n')

def main():
    try:
        sb = Sandbox(sys.argv)
        sb.execute()
    except SandboxUnavailableError as e:
        eprint('ERROR:', e)
        exit(1)
    except SandboxError as e:
        eprint('ERROR:', e)
        eprint('Use ++help for detailed usage instructions.')
        exit(1)


if __name__ == '__main__':
    main()
