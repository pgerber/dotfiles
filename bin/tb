#!/usr/bin/python3
import atexit
from pathlib import Path
from datetime import datetime, timezone
import enum
import fcntl
import functools
import itertools
import json
import os
import signal
import subprocess
import re
import tempfile
import shutil
import sys


eprint = functools.partial(print, file=sys.stderr)



class SandboxError(Exception):
    pass


class SandboxArgumentError(SandboxError):
    pass


class Type(enum.Enum):
    create = 0
    start = 1
    list = 2
    list_advanced = 3
    remove = 4
    help = 5


class Sandbox:
    base_dir = Path('~/.local/share/tor-browser-sandboxes').expanduser()
    link_dir = Path('~/td').expanduser()
    exec = 'sandboxed-tor-browser'
    pulse_cookie = Path('~/.config/pulse/cookie').expanduser()
    pulse_server = 'unix:/var/run/user/{}/pulse/native'.format(os.getuid())
    is_valid_name = re.compile('^[A-Za-z0-9_][A-Za-z0-9_-]*$')

    def __init__(self, args):
        self.name = None
        self.create_base_dir()

        arg = args[1] if len(args) > 1 else ''
        if arg == '++':  # list sandboxes
            self.type = Type.list
        elif arg.startswith('++add+'):  # create sandbox
            self.type = Type.create
            self.name = arg[6:]
            self.args = args[2:]
        elif arg.startswith('++del+'):  # remove sandbox
            self.type = Type.remove
            self.name = arg[6:]
        elif arg == '++help':
            self.type = Type.help
        elif arg == '++list':
            self.type = Type.list_advanced
        elif arg.startswith('++'):
            raise SandboxArgumentError('Unknown command {!r}.'.format(arg))
        elif arg == '+':
            raise SandboxArgumentError('Expected name after \'+\'')
        elif arg.startswith('+'): # start given sandbox
            self.type = Type.start
            self.name = arg[1:]
            self.args = args[2:]
        else:  # start and/or create an auto* sandbox
            self.type = Type.create
            self.name = self.find_free_auto()
            self.args = args[1:]

        if self.name is not None:
            self.path = self.base_dir / self.name

    def find_free_auto(self):
        prefix = 'auto'
        for i in itertools.count():
            name = prefix + str(i)
            try:
                self.lock(name)
                return name
            except BlockingIOError:
                pass

    def lock(self, name):
        lockfile = self.pid_file(name).open('a')
        fcntl.flock(lockfile.fileno(), fcntl.LOCK_EX|fcntl.LOCK_NB)
        lockfile.truncate(0)
        print(os.getpid(), file=lockfile)
        lockfile.flush()
        return lockfile


    def assert_sandbox_not_running(self, name):
        lock_file = self.base_dir / name / 'runtime' / 'sandboxed-tor-browser' / 'lock'
        if lock_file.exists():
            with lock_file.open() as f:
                fcntl.flock(f.fileno(), fcntl.LOCK_SH|fcntl.LOCK_NB)
                

    def is_locked(self, name):
        pid_file = self.pid_file(name)
        if not pid_file.exists():
            return False

        with pid_file.open() as f:
            try:
                fcntl.flock(f.fileno(), fcntl.LOCK_SH|fcntl.LOCK_NB)
                return False
            except BlockingIOError:
                return True

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, name):
        if name is not None and not self.is_valid_name.search(name):
            raise SandboxArgumentError('Sandbox name {!r} must match pattern {!r}.'.format(name, self.is_valid_name.pattern))
        self._name = name

    def pid_file(self, name):
        return self.base_dir / (name + '.pid')

    def create_sandbox(self):
        self.create_base_dir()
        self.create_download_link()

    def create_base_dir(self):
        self.base_dir.mkdir(mode=0o700, exist_ok=True)

    def create_download_link(self):
        self.link_dir.mkdir(mode=0o700, exist_ok=True)
        src = self.path / 'data' / 'sandboxed-tor-browser' / 'tor-browser' / 'Browser' / 'Downloads'
        dest = self.link_path()
        if not dest.is_symlink():
            dest.symlink_to(src, target_is_directory=True)

    def link_path(self):
        return self.link_dir / self.name

    def create_logfile(self):
        dir = '/dev/shm'
        if os.access(dir, os.W_OK) and os.path.ismount(dir):
            with tempfile.NamedTemporaryFile(mode='w', prefix='tb-{}-'.format(self.name), suffix='.log', dir=dir, delete=False) as f:
                json.dump({
                    'name': self.name,
                    'start': datetime.now(timezone.utc).astimezone().strftime('%Y-%m-%dT%H:%M:%S.%f%z'),
                    'pid': os.getpid(),
                    'args': self.args
                }, f)
                f.write('\n')
                f.flush()
            return f.name

    def execute(self):
        if self.type == Type.create:
            self.create_sandbox()
            self.args = [ '-advanced' ] + self.args
            self.start_sandbox()
        elif self.type == Type.start:
            self.check_sandbox_exists()
            self.start_sandbox()
        elif self.type == Type.list:
            self.print_sandboxes()
        elif self.type == Type.list_advanced:
            self.print_sandboxes_advanced()
        elif self.type == Type.remove:
            self.check_sandbox_exists()
            self.remove_sandbox()
        elif self.type == Type.help:
            self.usage()
        else:
            raise AssertionError()

    def start_sandbox(self):
        args = ['-debug']
        sigs = [ signal.SIGINT, signal.SIGTERM ]

        env = os.environ.copy()
        env.update(
            XDG_RUNTIME_DIR = (self.path / 'runtime').as_posix(),
            XDG_CONFIG_HOME = (self.path / 'config').as_posix(),
            XDG_DATA_HOME   = (self.path / 'data').as_posix(),
            PULSE_COOKIE    = self.pulse_cookie.as_posix(),
            PULSE_SERVER    = self.pulse_server
        )

        try:
            lock = self.lock(self.name)
        except BlockingIOError:
            raise SandboxError('Sandbox {!r} already running'.format(self.name))

        self.assert_sandbox_not_running(self.name)

        logfile = self.create_logfile()
        if logfile is not None:
            args.extend(['-l', logfile])

        proc = None

        def terminate(sig, stack_frame):
            if proc is not None:
                if sig is not None:
                    eprint('Received signal {}, terminating sandbox ...'.format(signal.Signals(sig).name))
                else:
                    eprint('Terminating sandbox ...')
                proc.terminate()
            if sig is not None:
                exit(1)

        atexit.register(terminate, None, None)
        for sig in sigs:
            signal.signal(sig, terminate)

        proc = subprocess.Popen([self.exec] + args + self.args, env=env)
        proc.communicate()
            

    def check_sandbox_exists(self):
        if not self.path.exists():
            raise SandboxError('No sandboxed named {!r}.'.format(self.name))

    def list_sandboxes(self):
        if self.base_dir.exists():
            return sorted(filter(lambda i: i.is_dir(), self.base_dir.iterdir()))
        else:
            return []

    def print_sandboxes(self):
        for sandbox in self.list_sandboxes():
            print(sandbox.stem)

    def print_sandboxes_advanced(self):
        print('NAME       PID      VERSION  CHANNEL  VOLATILE  AUDIO')
        for sandbox in self.list_sandboxes():
            if self.is_locked(sandbox.stem):
                pid_file = self.pid_file(sandbox.stem)
                with pid_file.open() as f:
                    running = f.read().strip()
            else:
                running = '-'
            config = self.parse_config(sandbox)
            print('{:10} {:8} {version:8} {channel:8} {volatile:9} {audio:5}'.format(sandbox.stem, running, **config))

    def parse_config(self, base_dir):
        sb_config = base_dir / 'config' / 'sandboxed-tor-browser' / 'sandboxed-tor-browser.json'
        manifest = base_dir / 'data' / 'sandboxed-tor-browser' / 'manifest.json'
        audio = '?'
        channel = '?'
        version = '?'
        volatile = '?'

        if sb_config.exists():
            with sb_config.open() as f:
                content = json.load(f)

            if not content.get('firstLaunch', True):
                channel = content.get('channel', '?')
                sandbox = content.get('sandbox')
                if sandbox is not None:
                    volatile = str(sandbox.get('enableAmnesiacProfileDirectory', '?'))
                    audio = str(sandbox.get('enablePulseAudio', '?'))

        if manifest.exists():
            with manifest.open() as f:
                content = json.load(f)
            version = content.get('version', '?')

        return { 'channel': channel, 'volatile': volatile, 'audio': audio, 'version': version }

    def remove_sandbox(self):
        def handler(func, path, exc):
            eprint('failed to remove {!r}: {}'.format(path, exc[1]))

        if self.path.exists():
            shutil.rmtree(self.path.as_posix(), onerror=handler)
        link = self.link_path()
        if link.is_symlink():
            link.unlink()

    @staticmethod
    def usage():
        eprint("Usage: {} [+NAME|++|++add+NAME|++del+NAME|++list] [ARG_FOR_SANDBOX]...".format(sys.argv[0]),
               "",
               "  ++help       show this text",
               "  +NAME        start sandbox with name NAME",
               "  ++           list available sandboxes (names only)",
               "  ++list       list available sandboxes with details",
               "  ++add+NAME   create and start sandbox with name NAME (starts sandbox",
               "               if it already exists)",
               "  ++del+NAME   irrecoverably remove sandbox with name",
               "",
               "  Only one argument starting with + is allowed and it must be",
               "  the first argument. The ARG_FOR_SANDBOX arguments are passed on",
               "  to the sandbox sandbox process. Obmitting the argument behaves",
               "  as if called with ++add+default.",
               sep='\n')

def main():
    try:
        sb = Sandbox(sys.argv)
        sb.execute()
    except SandboxArgumentError as e:
        eprint('ERROR:', e)
        eprint('Use ++help for detailed usage instructions.')
        exit(1)
    except SandboxError as e:
        eprint('ERROR:', e)
        exit(1)


if __name__ == '__main__':
    main()
