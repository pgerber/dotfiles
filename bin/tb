#!/usr/bin/python3
from pathlib import Path
import enum
import fcntl
import functools
import itertools
import json
import os
import re
import tempfile
import shutil
import sys


eprint = functools.partial(print, file=sys.stderr)



class SandboxError(Exception):
    pass


class Type(enum.Enum):
    create = 0
    start = 1
    list = 2
    list_advanced = 3
    remove = 4
    help = 5


class Sandbox:
    base_dir = Path('~/.local/share/tor-browser-sandboxes').expanduser()
    link_dir = Path('~/td').expanduser()
    exec = 'sandboxed-tor-browser'
    pulse_cookie = Path('~/.config/pulse/cookie').expanduser()
    pulse_server = 'unix:/var/run/user/{}/pulse/native'.format(os.getuid())
    is_valid_name = re.compile('^[A-Za-z0-9_][A-Za-z0-9_-]*$')

    def __init__(self, args):
        self.name = None
        self.create_base_dir()

        arg = args[1] if len(args) > 1 else ''
        if arg == '++':  # list sandboxes
            self.type = Type.list
        elif arg.startswith('++add+'):  # create sandbox
            self.type = Type.create
            self.name = arg[6:]
            self.args = args[2:]
        elif arg.startswith('++del+'):  # remove sandbox
            self.type = Type.remove
            self.name = arg[6:]
        elif arg == '++help':
            self.type = Type.help
        elif arg == '++list':
            self.type = Type.list_advanced
        elif arg.startswith('++'):
            raise SandboxError('Unknown command {!r}.'.format(arg))
        elif arg == '+':
            raise SandboxError('Expected name after \'+\'')
        elif arg.startswith('+'): # start given sandbox
            self.type = Type.start
            self.name = arg[1:]
            self.args = args[2:]
        else:  # start and/or create an auto* sandbox
            self.type = Type.create
            self.name = self.find_free_auto()
            self.args = args[1:]

        if self.name is not None:
            self.path = self.base_dir / self.name

    def find_free_auto(self):
        prefix = 'auto'
        for i in itertools.count():
            name = prefix + str(i)
            if not self.is_locked(name):
                return name

    def is_locked(self, name):
        lockfile = self.base_dir / name / 'runtime' / 'sandboxed-tor-browser' / 'lock'
        if not lockfile.exists():
            return False

        with lockfile.open() as f:
            try:
                fcntl.flock(f.fileno(), fcntl.LOCK_SH|fcntl.LOCK_NB)
                return False
            except BlockingIOError:
                return True

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, name):
        if name is not None and not self.is_valid_name.search(name):
            raise SandboxError('Sandbox name {!r} must match pattern {!r}.'.format(name, self.is_valid_name.pattern))
        self._name = name

    def create_sandbox(self):
        self.create_base_dir()
        self.create_download_link()

    def create_base_dir(self):
        self.base_dir.mkdir(mode=0o700, exist_ok=True)

    def create_download_link(self):
        self.link_dir.mkdir(mode=0o700, exist_ok=True)
        src = self.path / 'data' / 'sandboxed-tor-browser' / 'tor-browser' / 'Browser' / 'Downloads'
        dest = self.link_path()
        if not dest.is_symlink():
            dest.symlink_to(src, target_is_directory=True)

    def link_path(self):
        return self.link_dir / self.name

    def create_logfile(self):
        dir = '/dev/shm'
        if os.access(dir, os.W_OK) and os.path.ismount(dir):
            return tempfile.mktemp('.log', 'tb-{}-'.format(self.name), dir)

    def execute(self):
        if self.type == Type.create:
            self.create_sandbox()
            self.args = [ '-advanced' ] + self.args
            self.start_sandbox()
        elif self.type == Type.start:
            self.check_sandbox_exists()
            self.start_sandbox()
        elif self.type == Type.list:
            self.print_sandboxes()
        elif self.type == Type.list_advanced:
            self.print_sandboxes_advanced()
        elif self.type == Type.remove:
            self.check_sandbox_exists()
            self.remove_sandbox()
        elif self.type == Type.help:
            self.usage()
        else:
            raise AssertionError()

    def start_sandbox(self):
        args = ['-debug']
        logfile = self.create_logfile()
        if logfile is not None:
            args.extend(['-l', logfile])

        env = os.environ.copy()
        env.update(
            XDG_RUNTIME_DIR = (self.path / 'runtime').as_posix(),
            XDG_CONFIG_HOME = (self.path / 'config').as_posix(),
            XDG_DATA_HOME   = (self.path / 'data').as_posix(),
            PULSE_COOKIE    = self.pulse_cookie.as_posix(),
            PULSE_SERVER    = self.pulse_server
        )
        os.execvpe(self.exec, [self.exec] + args + self.args, env)

    def check_sandbox_exists(self):
        if not self.path.exists():
            raise SandboxError('No sandboxed named {!r}.'.format(self.name))

    def list_sandboxes(self):
        if self.base_dir.exists():
            return sorted(filter(lambda i: i.is_dir(), self.base_dir.iterdir()))
        else:
            return []

    def print_sandboxes(self):
        for sandbox in self.list_sandboxes():
            print(sandbox.stem)

    def print_sandboxes_advanced(self):
        print('NAME       RUNNING  VERSION  CHANNEL  VOLATILE  AUDIO')
        for sandbox in self.list_sandboxes():
            running = str(self.is_locked(sandbox))
            config = self.parse_config(sandbox)
            print('{:10} {:8} {version:8} {channel:8} {volatile:9} {audio:5}'.format(sandbox.stem, running, **config))

    def parse_config(self, base_dir):
        sb_config = base_dir / 'config' / 'sandboxed-tor-browser' / 'sandboxed-tor-browser.json'
        manifest = base_dir / 'data' / 'sandboxed-tor-browser' / 'manifest.json'
        audio = '?'
        channel = '?'
        version = '?'
        volatile = '?'

        if sb_config.exists():
            with sb_config.open() as f:
                content = json.load(f)

            if not content.get('firstLaunch', True):
                channel = content.get('channel', '?')
                sandbox = content.get('sandbox')
                if sandbox is not None:
                    volatile = str(sandbox.get('enableAmnesiacProfileDirectory', '?'))
                    audio = str(sandbox.get('enablePulseAudio', '?'))

        if manifest.exists():
            with manifest.open() as f:
                content = json.load(f)
            version = content.get('version', '?')

        return { 'channel': channel, 'volatile': volatile, 'audio': audio, 'version': version }

    def remove_sandbox(self):
        def handler(func, path, exc):
            eprint('failed to remove {!r}: {}'.format(path, exc[1]))

        if self.path.exists():
            shutil.rmtree(self.path.as_posix(), onerror=handler)
        link = self.link_path()
        if link.is_symlink():
            link.unlink()

    @staticmethod
    def usage():
        eprint("Usage: {} [+NAME|++|++add+NAME|++del+NAME|++list] [ARG_FOR_SANDBOX]...".format(sys.argv[0]),
               "",
               "  ++help       show this text",
               "  +NAME        start sandbox with name NAME",
               "  ++           list available sandboxes (names only)",
               "  ++list       list available sandboxes with details",
               "  ++add+NAME   create and start sandbox with name NAME (starts sandbox",
               "               if it already exists)",
               "  ++del+NAME   irrecoverably remove sandbox with name",
               "",
               "  Only one argument starting with + is allowed and it must be",
               "  the first argument. The ARG_FOR_SANDBOX arguments are passed on",
               "  to the sandbox sandbox process. Obmitting the argument behaves",
               "  as if called with ++add+default.",
               sep='\n')

def main():
    try:
        sb = Sandbox(sys.argv)
        sb.execute()
    except SandboxError as e:
        eprint(e)
        eprint('Use ++help for detailed usage instructions.')
        exit(1)


if __name__ == '__main__':
    main()
