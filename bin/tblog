#!/usr/bin/python3
import argparse
from datetime import datetime
import os
import pathlib
import re
import sys
import time


def is_logfile(path, name):
    if path.is_file() and path.stat().st_uid == os.getuid():
        match = re.fullmatch('tb-(.*)-.{8}\.log', path.name)
        return match and match.group(1) == name
    return False


def log_files(path, name):
    dir = pathlib.Path(path)
    logs = filter(lambda p: is_logfile(p, name), dir.iterdir())
    return sorted(logs, key=lambda p: p.stat().st_mtime, reverse=True)


def print_log(path, *, follow=False):
    with path.open() as f:
        while True:
            for line in f:
                print(line, end='')
            if not follow:
                break
            time.sleep(1)


def parse_args(args):
    parser = argparse.ArgumentParser(description='Show latest log file for given Tor Browser Sandbox.')
    parser.add_argument('name', nargs='?', default='default', help='sandbox name')
    parser.add_argument('--follow', '-f', action='store_true', help='follow output')
    parser.add_argument('--list', '-l', action='store_true', help='List available logs for given sandbox.')
    parser.add_argument('--previous', '-p', type=int, default=0,
                        help='Select a previous log file. 0 is the newest logfile, 1 the second newest and so on.')
    return parser.parse_args(args=args)


def print_logs(logs):
    print(" NO -                PATH                 -     MODIFICATION TIME")
    for no, log in enumerate(logs):
        print("{:3} - {:35} - {}".format(no, log.as_posix(), datetime.fromtimestamp(log.stat().st_mtime)))
    print()
    print('Use -p NO to select a log file (e.g. -p 0).')


def main(args):
    args = parse_args(args)
    logs = log_files('/dev/shm/', args.name)

    if not logs:
        print('No logfile for sandbox {!r} found.'.format(args.name), file=sys.stderr)
        return 1

    if args.list:
        print_logs(logs)
        return 0

    if 0 <= args.previous < len(logs):
        print_log(logs[args.previous], follow=args.follow)
        return 0

    print("Can't find previous log for sandbox {!r}. No log with number {}.".format(args.name, args.previous), file=sys.stderr)
    return 1


if __name__ == '__main__':
    try:
        exit(main(sys.argv[1:]))
    except KeyboardInterrupt:
        exit(130)
